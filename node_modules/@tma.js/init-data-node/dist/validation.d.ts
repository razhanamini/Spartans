import { BetterPromise, BetterPromiseOptions, BetterPromiseRejectReason } from 'better-promises';
import { AuthDateInvalidError, ExpiredError, SignatureInvalidError, SignatureMissingError } from './errors.js';
import { Text } from './types.js';
import * as E from 'fp-ts/Either';
import * as TE from 'fp-ts/TaskEither';
type OmittedPromiseOptions = Omit<BetterPromiseOptions, 'abortOnResolve' | 'abortOnReject'>;
export type ValidateValue = string | URLSearchParams;
export type Validate3rdValue = string | URLSearchParams;
export type ValidateError = SignatureMissingError | SignatureInvalidError | AuthDateInvalidError | ExpiredError;
export type ValidateAsyncError = ValidateError | BetterPromiseRejectReason;
export type Validate3rdError = SignatureMissingError | SignatureInvalidError | AuthDateInvalidError | ExpiredError | BetterPromiseRejectReason;
interface ValidateSignDataFpArg<Async extends boolean, Left> {
    (data: Text, key: Text, options?: ValidateOptions): Async extends true ? TE.TaskEither<Left, string> : E.Either<Left, string>;
}
interface SharedValidateOptions {
    /**
     * Time in seconds which states, how long from creation time init data is considered valid.
     *
     * In other words, in case when authDate + expiresIn is before current time, init data is
     * recognized as expired.
     *
     * In case this value is equal to 0, the function does not check init data expiration.
     * @default 86400 (1 day)
     */
    expiresIn?: number;
}
export interface ValidateOptions extends SharedValidateOptions {
    /**
     * True, if token is already hashed.
     * @default false
     */
    tokenHashed?: boolean;
}
export interface ValidateAsyncOptions extends ValidateOptions, OmittedPromiseOptions {
}
export interface Validate3rdOptions extends SharedValidateOptions, OmittedPromiseOptions {
    /**
     * When true, uses the test environment public key to validate init data.
     * @default false
     */
    test?: boolean;
}
/**
 * Validates passed init data using a publicly known Ee25519 key.
 * @param value - value to check.
 * @param botId - bot identifier
 * @param options - additional validation options.
 */
export declare function validate3rdFp(value: Validate3rdValue, botId: number, options?: Validate3rdOptions): TE.TaskEither<Validate3rdError, void>;
/**
 * @see validate3rdFp
 */
export declare function validate3rd(value: Validate3rdValue, botId: number, options?: Validate3rdOptions): BetterPromise<void>;
/**
 * @param value - value to check.
 * @param botId - bot identifier
 * @param options - additional validation options.
 * @returns True is specified init data is signed by Telegram.
 */
export declare function isValid3rdFp(value: Validate3rdValue, botId: number, options?: Validate3rdOptions): TE.TaskEither<void, boolean>;
/**
 * @see isValid3rdFp
 */
export declare function isValid3rd(value: Validate3rdValue, botId: number, options?: Validate3rdOptions): BetterPromise<boolean>;
export declare function validateFp<Left>(async: false, value: ValidateValue, token: Text, signData: ValidateSignDataFpArg<false, Left>, options?: ValidateOptions): E.Either<Left | ValidateError, void>;
export declare function validateFp<Left>(async: true, value: ValidateValue, token: Text, signData: ValidateSignDataFpArg<true, Left>, options?: ValidateAsyncOptions): TE.TaskEither<Left | ValidateAsyncError, void>;
export {};
