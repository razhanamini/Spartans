{"version":3,"file":"web.js","sources":["../../src/entries/web.ts"],"sourcesContent":["import { BetterPromise, type BetterPromiseRejectReason } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/lib/function.js';\n\nimport {\n  AuthDateInvalidError,\n  ExpiredError,\n  SignatureInvalidError,\n  SignatureMissingError,\n  HexStringLengthInvalidError,\n} from '../errors.js';\nimport { hashToken as _hashToken } from '../hashToken.js';\nimport { signDataFp as _signDataFp, SignDataError, type SignDataOptions } from '../signDataFp.js';\nimport {\n  signFp as _signFp,\n  type SignableData,\n  type SignOptions,\n} from '../signFp.js';\nimport type { CreateHmacFn, Text } from '../types.js';\nimport {\n  validateFp as _validateFp,\n  type ValidateValue,\n  type ValidateAsyncError,\n  type ValidateAsyncOptions,\n} from '../validation.js';\n\nconst createHmac: CreateHmacFn<true> = async (data, key) => {\n  const encoder = new TextEncoder();\n\n  return crypto.subtle.sign(\n    'HMAC',\n    await crypto.subtle.importKey(\n      'raw',\n      typeof key === 'string' ? encoder.encode(key) : key,\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['sign', 'verify'],\n    ),\n    typeof data === 'string' ? encoder.encode(data) : data,\n  );\n};\n\n/**\n * Hashes specified token using a string, expected during init data sign.\n * @param token - token to hash.\n */\nexport function hashToken(token: Text): Promise<ArrayBuffer> {\n  return _hashToken(token, createHmac);\n}\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValidFp(\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateAsyncOptions,\n): TE.TaskEither<BetterPromiseRejectReason, boolean> {\n  return pipe(\n    validateFp(value, token, options),\n    TE.match(\n      error => {\n        return [\n          AuthDateInvalidError,\n          ExpiredError,\n          SignatureInvalidError,\n          SignatureMissingError,\n          HexStringLengthInvalidError,\n        ].some(errorClass => errorClass.is(error))\n          ? E.right(false)\n          : E.left(error);\n      },\n      () => E.right(true),\n    ),\n  );\n}\n\n/**\n * @see isValidFp\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateAsyncOptions,\n): BetterPromise<boolean> {\n  return BetterPromise.fn(() => {\n    return pipe(\n      isValidFp(value, token, options),\n      TE.match(error => {\n        throw error;\n      }, isValid => isValid),\n    )();\n  });\n}\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function signFp(\n  data: SignableData,\n  key: Text,\n  authDate: Date,\n  options?: SignOptions,\n): TE.TaskEither<SignDataError, string> {\n  return _signFp(data, key, authDate, signDataFp, options);\n}\n\n/**\n * @see signFp\n */\nexport function sign(\n  data: SignableData,\n  key: Text,\n  authDate: Date,\n  options?: SignOptions,\n): BetterPromise<string> {\n  return BetterPromise.fn(() => {\n    return pipe(\n      signFp(data, key, authDate, options),\n      TE.match(e => {\n        throw e;\n      }, v => v),\n    )();\n  });\n}\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param options - additional options.\n * @returns Data sign.\n */\nexport function signDataFp(\n  data: Text,\n  key: Text,\n  options?: SignDataOptions,\n): TE.TaskEither<SignDataError, string> {\n  return _signDataFp(true, data, key, createHmac, options);\n}\n\n/**\n * @see signDataFp\n */\nexport function signData(data: Text, key: Text, options?: SignDataOptions): BetterPromise<string> {\n  return BetterPromise.fn(() => {\n    return pipe(\n      signDataFp(data, key, options),\n      TE.match(e => {\n        throw e;\n      }, v => v),\n    )();\n  });\n}\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param options - additional validation options.\n */\nexport function validateFp(\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateAsyncOptions,\n): TE.TaskEither<ValidateAsyncError, void> {\n  return _validateFp(true, value, token, signDataFp, options);\n}\n\n/**\n * @see validateFp\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateAsyncOptions,\n): BetterPromise<void> {\n  return BetterPromise.fn(async () => {\n    await pipe(\n      validateFp(value, token, options),\n      TE.mapLeft(error => {\n        throw error;\n      }),\n    )();\n  });\n}\n\nexport * from './shared.js';\n"],"names":["_hashToken","isValid","_signFp","e","_signDataFp","_validateFp"],"mappings":";;;;;;;AA2BA,MAAM,aAAiC,OAAO,MAAM,QAAQ;AACpD,QAAA,UAAU,IAAI,YAAY;AAEhC,SAAO,OAAO,OAAO;AAAA,IACnB;AAAA,IACA,MAAM,OAAO,OAAO;AAAA,MAClB;AAAA,MACA,OAAO,QAAQ,WAAW,QAAQ,OAAO,GAAG,IAAI;AAAA,MAChD,EAAE,MAAM,QAAQ,MAAM,UAAU;AAAA,MAChC;AAAA,MACA,CAAC,QAAQ,QAAQ;AAAA,IACnB;AAAA,IACA,OAAO,SAAS,WAAW,QAAQ,OAAO,IAAI,IAAI;AAAA,EACpD;AACF;AAMO,SAAS,UAAU,OAAmC;AACpD,SAAAA,YAAW,OAAO,UAAU;AACrC;AAQgB,SAAA,UACd,OACA,OACA,SACmD;AAC5C,SAAA;AAAA,IACL,WAAW,OAAO,OAAO,OAAO;AAAA,IAChC,GAAG;AAAA,MACD,CAAS,UAAA;AACA,eAAA;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACA,EAAA,KAAK,CAAc,eAAA,WAAW,GAAG,KAAK,CAAC,IACrC,EAAE,MAAM,KAAK,IACb,EAAE,KAAK,KAAK;AAAA,MAClB;AAAA,MACA,MAAM,EAAE,MAAM,IAAI;AAAA,IAAA;AAAA,EAEtB;AACF;AAKgB,SAAA,QACd,OACA,OACA,SACwB;AACjB,SAAA,cAAc,GAAG,MAAM;AACrB,WAAA;AAAA,MACL,UAAU,OAAO,OAAO,OAAO;AAAA,MAC/B,GAAG,MAAM,CAAS,UAAA;AACV,cAAA;AAAA,MAAA,GACL,CAAAC,aAAWA,QAAO;AAAA,IAAA,EACrB;AAAA,EAAA,CACH;AACH;AAUO,SAAS,OACd,MACA,KACA,UACA,SACsC;AACtC,SAAOC,SAAQ,MAAM,KAAK,UAAU,YAAY,OAAO;AACzD;AAKO,SAAS,KACd,MACA,KACA,UACA,SACuB;AAChB,SAAA,cAAc,GAAG,MAAM;AACrB,WAAA;AAAA,MACL,OAAO,MAAM,KAAK,UAAU,OAAO;AAAA,MACnC,GAAG,MAAM,CAAKC,OAAA;AACN,cAAAA;AAAA,MAAA,GACL,OAAK,CAAC;AAAA,IAAA,EACT;AAAA,EAAA,CACH;AACH;AASgB,SAAA,WACd,MACA,KACA,SACsC;AACtC,SAAOC,aAAY,MAAM,MAAM,KAAK,YAAY,OAAO;AACzD;AAKgB,SAAA,SAAS,MAAY,KAAW,SAAkD;AACzF,SAAA,cAAc,GAAG,MAAM;AACrB,WAAA;AAAA,MACL,WAAW,MAAM,KAAK,OAAO;AAAA,MAC7B,GAAG,MAAM,CAAKD,OAAA;AACN,cAAAA;AAAA,MAAA,GACL,OAAK,CAAC;AAAA,IAAA,EACT;AAAA,EAAA,CACH;AACH;AAQgB,SAAA,WACd,OACA,OACA,SACyC;AACzC,SAAOE,aAAY,MAAM,OAAO,OAAO,YAAY,OAAO;AAC5D;AAKgB,SAAA,SACd,OACA,OACA,SACqB;AACd,SAAA,cAAc,GAAG,YAAY;AAC5B,UAAA;AAAA,MACJ,WAAW,OAAO,OAAO,OAAO;AAAA,MAChC,GAAG,QAAQ,CAAS,UAAA;AACZ,cAAA;AAAA,MACP,CAAA;AAAA,IAAA,EACD;AAAA,EAAA,CACH;AACH;"}