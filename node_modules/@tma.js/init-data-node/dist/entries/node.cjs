"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const E = require("fp-ts/Either");
const function_js = require("fp-ts/lib/function.js");
const node_crypto = require("node:crypto");
const parsing = require("./parsing-pEQ1lsuE.cjs");
const toolkit = require("@tma.js/toolkit");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const E__namespace = /* @__PURE__ */ _interopNamespaceDefault(E);
function textToBuffer(text) {
  return Buffer.from(typeof text === "string" ? text : new Uint8Array(text));
}
const createHmac = (data, key) => {
  return parsing.bufferToArrayBuffer(
    node_crypto.createHmac("sha256", textToBuffer(key)).update(textToBuffer(data)).digest()
  );
};
function hashToken(token) {
  return Buffer.from(parsing.hashToken(token, createHmac));
}
function isValid(value, token, options) {
  return function_js.pipe(
    validateFp(value, token, options),
    E__namespace.match(() => false, () => true)
  );
}
function signFp(data, key, authDate, options) {
  return parsing.signFp(data, key, authDate, signDataFp, options);
}
function sign(data, key, authDate, options) {
  return function_js.pipe(
    signFp(data, key, authDate, options),
    E__namespace.match((e) => {
      throw e;
    }, (v) => v)
  );
}
function signDataFp(data, key, options) {
  return parsing.signDataFp(false, data, key, createHmac, options);
}
function signData(data, key, options) {
  return function_js.pipe(
    signDataFp(data, key, options),
    E__namespace.match((e) => {
      throw e;
    }, (v) => v)
  );
}
function validateFp(value, token, options) {
  return parsing.validateFp(false, value, token, signDataFp, options);
}
function validate(value, token, options) {
  function_js.pipe(
    validateFp(value, token, options),
    E__namespace.mapLeft((error) => {
      throw error;
    })
  );
}
exports.AuthDateInvalidError = parsing.AuthDateInvalidError;
exports.ExpiredError = parsing.ExpiredError;
exports.HexStringLengthInvalidError = parsing.HexStringLengthInvalidError;
exports.SignatureInvalidError = parsing.SignatureInvalidError;
exports.SignatureMissingError = parsing.SignatureMissingError;
exports.isValid3rd = parsing.isValid3rd;
exports.isValid3rdFp = parsing.isValid3rdFp;
exports.parse = parsing.parse;
exports.parseFp = parsing.parseFp;
exports.validate3rd = parsing.validate3rd;
exports.validate3rdFp = parsing.validate3rdFp;
Object.defineProperty(exports, "deepSnakeToCamelObjKeys", {
  enumerable: true,
  get: () => toolkit.deepSnakeToCamelObjKeys
});
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.sign = sign;
exports.signData = signData;
exports.signDataFp = signDataFp;
exports.signFp = signFp;
exports.validate = validate;
exports.validateFp = validateFp;
//# sourceMappingURL=node.cjs.map
