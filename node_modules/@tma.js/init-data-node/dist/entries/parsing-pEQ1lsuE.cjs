"use strict";
const E = require("fp-ts/Either");
const TE = require("fp-ts/TaskEither");
const function_js = require("fp-ts/lib/function.js");
const transformers = require("@tma.js/transformers");
const betterPromises = require("better-promises");
const _function = require("fp-ts/function");
const errorKid = require("error-kid");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const E__namespace = /* @__PURE__ */ _interopNamespaceDefault(E);
const TE__namespace = /* @__PURE__ */ _interopNamespaceDefault(TE);
class AuthDateInvalidError extends errorKid.errorClassWithData(
  "AuthDateInvalidError",
  (value) => ({ value }),
  (value) => [`"auth_date" is invalid: ${value || "value is missing"}`]
) {
}
class SignatureInvalidError extends errorKid.errorClass("SignatureInvalidError") {
}
class HexStringLengthInvalidError extends errorKid.errorClass(
  "HexStringLengthInvalidError"
) {
}
class SignatureMissingError extends errorKid.errorClass(
  "SignatureMissingError",
  (thirdParty) => [`"${thirdParty ? "signature" : "hash"}" parameter is missing`]
) {
}
class ExpiredError extends errorKid.errorClassWithData(
  "ExpiredError",
  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),
  (issuedAt, expiresAt, now) => [
    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`
  ]
) {
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    return E__namespace.left(new HexStringLengthInvalidError());
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < hexString.length; i += 2) {
    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return E__namespace.right(buffer);
}
function arrayBufferToHex(arrBuf) {
  return new Uint8Array(arrBuf).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function bufferToArrayBuffer(buf) {
  const ab = new ArrayBuffer(buf.length);
  buf.copy(new Uint8Array(ab));
  return ab;
}
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function signDataFp(async, data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : E__namespace.right(key) : function_js.pipe(
    E__namespace.right(hashToken(key, createHmac)),
    E__namespace.match(() => null, (v) => {
      return v instanceof Promise ? TE__namespace.tryCatch(() => v, (err) => err) : E__namespace.right(v);
    })
  );
  if (async || typeof keyHmac === "function") {
    return function_js.pipe(
      typeof keyHmac === "function" ? keyHmac : TE__namespace.fromEither(keyHmac),
      TE__namespace.chain((v) => TE__namespace.tryCatch(
        () => Promise.resolve(createHmac(data, v)).then(arrayBufferToHex),
        (err) => err
      ))
    );
  }
  return function_js.pipe(
    keyHmac,
    // In this branch createHmac can't be asynchronous. If it is, keyHmac would be Promise and the
    // result would be returned in the previous "if" statement.
    E__namespace.chain((v) => E__namespace.right(
      arrayBufferToHex(createHmac(data, v))
    ))
  );
}
function signFp(data, key, authDate, signData, options) {
  const query = new URLSearchParams(transformers.serializeInitDataQuery({
    ...data,
    auth_date: authDate,
    signature: data.signature || ""
  }));
  const pairs = [...query.entries()].map(([name, value]) => `${name}=${value}`).sort();
  const queryWithHash = (signature) => {
    query.append("hash", signature);
    return query.toString();
  };
  const eitherHash = signData(pairs.join("\n"), key, options);
  return typeof eitherHash === "function" ? function_js.pipe(eitherHash, TE__namespace.chain((hash) => TE__namespace.right(queryWithHash(hash)))) : function_js.pipe(eitherHash, E__namespace.chain((hash) => E__namespace.right(queryWithHash(hash))));
}
function validate3rdFp(value, botId, options = {}) {
  let authDate;
  let authDateString;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    return TE__namespace.left(new SignatureMissingError(true));
  }
  if (!authDate) {
    return TE__namespace.left(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return TE__namespace.left(new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs)));
    }
  }
  return _function.pipe(
    TE__namespace.tryCatch(
      () => {
        return betterPromises.BetterPromise.fn(async () => {
          return crypto.subtle.verify(
            "Ed25519",
            await crypto.subtle.importKey(
              "raw",
              Buffer.from(
                options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
                "hex"
              ),
              "Ed25519",
              false,
              ["verify"]
            ),
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            Buffer.from(signature, "base64"),
            Buffer.from(`${botId}:WebAppData
${pairs.sort().join("\n")}`)
          );
        }, options);
      },
      (e) => e
    ),
    TE__namespace.chainW((isVerified) => {
      return isVerified ? TE__namespace.right(void 0) : TE__namespace.left(new SignatureInvalidError());
    })
  );
}
function validate3rd(value, botId, options) {
  return betterPromises.BetterPromise.fn(async () => {
    await _function.pipe(
      validate3rdFp(value, botId, options),
      TE__namespace.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
function isValid3rdFp(value, botId, options) {
  return _function.pipe(validate3rdFp(value, botId, options), TE__namespace.match(
    () => E__namespace.right(false),
    () => E__namespace.right(true)
  ));
}
function isValid3rd(value, botId, options) {
  return betterPromises.BetterPromise.fn(() => _function.pipe(
    isValid3rdFp(value, botId, options),
    TE__namespace.match(() => false, (v) => v)
  )());
}
function validateFp(async, value, token, signData, options = {}) {
  let authDate;
  let authDateString;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    return (async ? TE__namespace.left : E__namespace.left)(new SignatureMissingError(false));
  }
  if (!authDate) {
    return (async ? TE__namespace.left : E__namespace.left)(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return (async ? TE__namespace.left : E__namespace.left)(
        new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs))
      );
    }
  }
  pairs.sort();
  const eitherSignature = signData(pairs.join("\n"), token, options);
  const onLeft = (error) => E__namespace.left(error);
  const onRight = (signature) => signature === hash ? E__namespace.right(void 0) : E__namespace.left(new SignatureInvalidError());
  return typeof eitherSignature === "function" ? _function.pipe(eitherSignature, TE__namespace.matchW(onLeft, onRight)) : _function.pipe(eitherSignature, E__namespace.matchW(onLeft, onRight));
}
const parse = transformers.parseInitDataQuery;
const parseFp = transformers.parseInitDataQueryFp;
exports.AuthDateInvalidError = AuthDateInvalidError;
exports.ExpiredError = ExpiredError;
exports.HexStringLengthInvalidError = HexStringLengthInvalidError;
exports.SignatureInvalidError = SignatureInvalidError;
exports.SignatureMissingError = SignatureMissingError;
exports.bufferToArrayBuffer = bufferToArrayBuffer;
exports.hashToken = hashToken;
exports.isValid3rd = isValid3rd;
exports.isValid3rdFp = isValid3rdFp;
exports.parse = parse;
exports.parseFp = parseFp;
exports.signDataFp = signDataFp;
exports.signFp = signFp;
exports.validate3rd = validate3rd;
exports.validate3rdFp = validate3rdFp;
exports.validateFp = validateFp;
//# sourceMappingURL=parsing-pEQ1lsuE.cjs.map
