import { BetterPromise } from "better-promises";
import * as E from "fp-ts/Either";
import * as TE from "fp-ts/TaskEither";
import { pipe } from "fp-ts/lib/function.js";
import { h as hashToken$1, A as AuthDateInvalidError, E as ExpiredError, S as SignatureInvalidError, c as SignatureMissingError, H as HexStringLengthInvalidError, s as signFp$1, a as signDataFp$1, v as validateFp$1 } from "./parsing-B9llLYuO.js";
import { i, e, p, d, f, g } from "./parsing-B9llLYuO.js";
import { deepSnakeToCamelObjKeys } from "@tma.js/toolkit";
const createHmac = async (data, key) => {
  const encoder = new TextEncoder();
  return crypto.subtle.sign(
    "HMAC",
    await crypto.subtle.importKey(
      "raw",
      typeof key === "string" ? encoder.encode(key) : key,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign", "verify"]
    ),
    typeof data === "string" ? encoder.encode(data) : data
  );
};
function hashToken(token) {
  return hashToken$1(token, createHmac);
}
function isValidFp(value, token, options) {
  return pipe(
    validateFp(value, token, options),
    TE.match(
      (error) => {
        return [
          AuthDateInvalidError,
          ExpiredError,
          SignatureInvalidError,
          SignatureMissingError,
          HexStringLengthInvalidError
        ].some((errorClass) => errorClass.is(error)) ? E.right(false) : E.left(error);
      },
      () => E.right(true)
    )
  );
}
function isValid(value, token, options) {
  return BetterPromise.fn(() => {
    return pipe(
      isValidFp(value, token, options),
      TE.match((error) => {
        throw error;
      }, (isValid2) => isValid2)
    )();
  });
}
function signFp(data, key, authDate, options) {
  return signFp$1(data, key, authDate, signDataFp, options);
}
function sign(data, key, authDate, options) {
  return BetterPromise.fn(() => {
    return pipe(
      signFp(data, key, authDate, options),
      TE.match((e2) => {
        throw e2;
      }, (v) => v)
    )();
  });
}
function signDataFp(data, key, options) {
  return signDataFp$1(true, data, key, createHmac, options);
}
function signData(data, key, options) {
  return BetterPromise.fn(() => {
    return pipe(
      signDataFp(data, key, options),
      TE.match((e2) => {
        throw e2;
      }, (v) => v)
    )();
  });
}
function validateFp(value, token, options) {
  return validateFp$1(true, value, token, signDataFp, options);
}
function validate(value, token, options) {
  return BetterPromise.fn(async () => {
    await pipe(
      validateFp(value, token, options),
      TE.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
export {
  AuthDateInvalidError,
  ExpiredError,
  HexStringLengthInvalidError,
  SignatureInvalidError,
  SignatureMissingError,
  deepSnakeToCamelObjKeys,
  hashToken,
  isValid,
  i as isValid3rd,
  e as isValid3rdFp,
  isValidFp,
  p as parse,
  d as parseFp,
  sign,
  signData,
  signDataFp,
  signFp,
  validate,
  f as validate3rd,
  g as validate3rdFp,
  validateFp
};
//# sourceMappingURL=web.js.map
