import * as E from "fp-ts/Either";
import * as TE from "fp-ts/TaskEither";
import { pipe } from "fp-ts/lib/function.js";
import { serializeInitDataQuery, parseInitDataQuery, parseInitDataQueryFp } from "@tma.js/transformers";
import { BetterPromise } from "better-promises";
import { pipe as pipe$1 } from "fp-ts/function";
import { errorClassWithData, errorClass } from "error-kid";
class AuthDateInvalidError extends errorClassWithData(
  "AuthDateInvalidError",
  (value) => ({ value }),
  (value) => [`"auth_date" is invalid: ${value || "value is missing"}`]
) {
}
class SignatureInvalidError extends errorClass("SignatureInvalidError") {
}
class HexStringLengthInvalidError extends errorClass(
  "HexStringLengthInvalidError"
) {
}
class SignatureMissingError extends errorClass(
  "SignatureMissingError",
  (thirdParty) => [`"${thirdParty ? "signature" : "hash"}" parameter is missing`]
) {
}
class ExpiredError extends errorClassWithData(
  "ExpiredError",
  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),
  (issuedAt, expiresAt, now) => [
    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`
  ]
) {
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    return E.left(new HexStringLengthInvalidError());
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < hexString.length; i += 2) {
    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return E.right(buffer);
}
function arrayBufferToHex(arrBuf) {
  return new Uint8Array(arrBuf).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function bufferToArrayBuffer(buf) {
  const ab = new ArrayBuffer(buf.length);
  buf.copy(new Uint8Array(ab));
  return ab;
}
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function signDataFp(async, data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : E.right(key) : pipe(
    E.right(hashToken(key, createHmac)),
    E.match(() => null, (v) => {
      return v instanceof Promise ? TE.tryCatch(() => v, (err) => err) : E.right(v);
    })
  );
  if (async || typeof keyHmac === "function") {
    return pipe(
      typeof keyHmac === "function" ? keyHmac : TE.fromEither(keyHmac),
      TE.chain((v) => TE.tryCatch(
        () => Promise.resolve(createHmac(data, v)).then(arrayBufferToHex),
        (err) => err
      ))
    );
  }
  return pipe(
    keyHmac,
    // In this branch createHmac can't be asynchronous. If it is, keyHmac would be Promise and the
    // result would be returned in the previous "if" statement.
    E.chain((v) => E.right(
      arrayBufferToHex(createHmac(data, v))
    ))
  );
}
function signFp(data, key, authDate, signData, options) {
  const query = new URLSearchParams(serializeInitDataQuery({
    ...data,
    auth_date: authDate,
    signature: data.signature || ""
  }));
  const pairs = [...query.entries()].map(([name, value]) => `${name}=${value}`).sort();
  const queryWithHash = (signature) => {
    query.append("hash", signature);
    return query.toString();
  };
  const eitherHash = signData(pairs.join("\n"), key, options);
  return typeof eitherHash === "function" ? pipe(eitherHash, TE.chain((hash) => TE.right(queryWithHash(hash)))) : pipe(eitherHash, E.chain((hash) => E.right(queryWithHash(hash))));
}
function validate3rdFp(value, botId, options = {}) {
  let authDate;
  let authDateString;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    return TE.left(new SignatureMissingError(true));
  }
  if (!authDate) {
    return TE.left(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return TE.left(new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs)));
    }
  }
  return pipe$1(
    TE.tryCatch(
      () => {
        return BetterPromise.fn(async () => {
          return crypto.subtle.verify(
            "Ed25519",
            await crypto.subtle.importKey(
              "raw",
              Buffer.from(
                options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
                "hex"
              ),
              "Ed25519",
              false,
              ["verify"]
            ),
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            Buffer.from(signature, "base64"),
            Buffer.from(`${botId}:WebAppData
${pairs.sort().join("\n")}`)
          );
        }, options);
      },
      (e) => e
    ),
    TE.chainW((isVerified) => {
      return isVerified ? TE.right(void 0) : TE.left(new SignatureInvalidError());
    })
  );
}
function validate3rd(value, botId, options) {
  return BetterPromise.fn(async () => {
    await pipe$1(
      validate3rdFp(value, botId, options),
      TE.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
function isValid3rdFp(value, botId, options) {
  return pipe$1(validate3rdFp(value, botId, options), TE.match(
    () => E.right(false),
    () => E.right(true)
  ));
}
function isValid3rd(value, botId, options) {
  return BetterPromise.fn(() => pipe$1(
    isValid3rdFp(value, botId, options),
    TE.match(() => false, (v) => v)
  )());
}
function validateFp(async, value, token, signData, options = {}) {
  let authDate;
  let authDateString;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    return (async ? TE.left : E.left)(new SignatureMissingError(false));
  }
  if (!authDate) {
    return (async ? TE.left : E.left)(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return (async ? TE.left : E.left)(
        new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs))
      );
    }
  }
  pairs.sort();
  const eitherSignature = signData(pairs.join("\n"), token, options);
  const onLeft = (error) => E.left(error);
  const onRight = (signature) => signature === hash ? E.right(void 0) : E.left(new SignatureInvalidError());
  return typeof eitherSignature === "function" ? pipe$1(eitherSignature, TE.matchW(onLeft, onRight)) : pipe$1(eitherSignature, E.matchW(onLeft, onRight));
}
const parse = parseInitDataQuery;
const parseFp = parseInitDataQueryFp;
export {
  AuthDateInvalidError as A,
  ExpiredError as E,
  HexStringLengthInvalidError as H,
  SignatureInvalidError as S,
  signDataFp as a,
  bufferToArrayBuffer as b,
  SignatureMissingError as c,
  parseFp as d,
  isValid3rdFp as e,
  validate3rd as f,
  validate3rdFp as g,
  hashToken as h,
  isValid3rd as i,
  parse as p,
  signFp as s,
  validateFp as v
};
//# sourceMappingURL=parsing-B9llLYuO.js.map
