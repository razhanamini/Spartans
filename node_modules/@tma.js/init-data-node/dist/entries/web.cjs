"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const betterPromises = require("better-promises");
const E = require("fp-ts/Either");
const TE = require("fp-ts/TaskEither");
const function_js = require("fp-ts/lib/function.js");
const parsing = require("./parsing-pEQ1lsuE.cjs");
const toolkit = require("@tma.js/toolkit");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const E__namespace = /* @__PURE__ */ _interopNamespaceDefault(E);
const TE__namespace = /* @__PURE__ */ _interopNamespaceDefault(TE);
const createHmac = async (data, key) => {
  const encoder = new TextEncoder();
  return crypto.subtle.sign(
    "HMAC",
    await crypto.subtle.importKey(
      "raw",
      typeof key === "string" ? encoder.encode(key) : key,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign", "verify"]
    ),
    typeof data === "string" ? encoder.encode(data) : data
  );
};
function hashToken(token) {
  return parsing.hashToken(token, createHmac);
}
function isValidFp(value, token, options) {
  return function_js.pipe(
    validateFp(value, token, options),
    TE__namespace.match(
      (error) => {
        return [
          parsing.AuthDateInvalidError,
          parsing.ExpiredError,
          parsing.SignatureInvalidError,
          parsing.SignatureMissingError,
          parsing.HexStringLengthInvalidError
        ].some((errorClass) => errorClass.is(error)) ? E__namespace.right(false) : E__namespace.left(error);
      },
      () => E__namespace.right(true)
    )
  );
}
function isValid(value, token, options) {
  return betterPromises.BetterPromise.fn(() => {
    return function_js.pipe(
      isValidFp(value, token, options),
      TE__namespace.match((error) => {
        throw error;
      }, (isValid2) => isValid2)
    )();
  });
}
function signFp(data, key, authDate, options) {
  return parsing.signFp(data, key, authDate, signDataFp, options);
}
function sign(data, key, authDate, options) {
  return betterPromises.BetterPromise.fn(() => {
    return function_js.pipe(
      signFp(data, key, authDate, options),
      TE__namespace.match((e) => {
        throw e;
      }, (v) => v)
    )();
  });
}
function signDataFp(data, key, options) {
  return parsing.signDataFp(true, data, key, createHmac, options);
}
function signData(data, key, options) {
  return betterPromises.BetterPromise.fn(() => {
    return function_js.pipe(
      signDataFp(data, key, options),
      TE__namespace.match((e) => {
        throw e;
      }, (v) => v)
    )();
  });
}
function validateFp(value, token, options) {
  return parsing.validateFp(true, value, token, signDataFp, options);
}
function validate(value, token, options) {
  return betterPromises.BetterPromise.fn(async () => {
    await function_js.pipe(
      validateFp(value, token, options),
      TE__namespace.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
exports.AuthDateInvalidError = parsing.AuthDateInvalidError;
exports.ExpiredError = parsing.ExpiredError;
exports.HexStringLengthInvalidError = parsing.HexStringLengthInvalidError;
exports.SignatureInvalidError = parsing.SignatureInvalidError;
exports.SignatureMissingError = parsing.SignatureMissingError;
exports.isValid3rd = parsing.isValid3rd;
exports.isValid3rdFp = parsing.isValid3rdFp;
exports.parse = parsing.parse;
exports.parseFp = parsing.parseFp;
exports.validate3rd = parsing.validate3rd;
exports.validate3rdFp = parsing.validate3rdFp;
Object.defineProperty(exports, "deepSnakeToCamelObjKeys", {
  enumerable: true,
  get: () => toolkit.deepSnakeToCamelObjKeys
});
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.isValidFp = isValidFp;
exports.sign = sign;
exports.signData = signData;
exports.signDataFp = signDataFp;
exports.signFp = signFp;
exports.validate = validate;
exports.validateFp = validateFp;
//# sourceMappingURL=web.cjs.map
